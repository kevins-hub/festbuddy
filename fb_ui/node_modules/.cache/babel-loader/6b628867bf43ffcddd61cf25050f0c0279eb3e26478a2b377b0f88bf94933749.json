{"ast":null,"code":"import { useEffect } from 'react';\nimport { useTrackVisibility } from 'react-intersection-observer-hook';\nvar DEFAULT_DELAY_IN_MS = 100;\nfunction useInfiniteScroll(_ref) {\n  var loading = _ref.loading,\n    hasNextPage = _ref.hasNextPage,\n    onLoadMore = _ref.onLoadMore,\n    rootMargin = _ref.rootMargin,\n    disabled = _ref.disabled,\n    _ref$delayInMs = _ref.delayInMs,\n    delayInMs = _ref$delayInMs === void 0 ? DEFAULT_DELAY_IN_MS : _ref$delayInMs;\n  var _useTrackVisibility = useTrackVisibility({\n      rootMargin: rootMargin\n    }),\n    ref = _useTrackVisibility[0],\n    _useTrackVisibility$ = _useTrackVisibility[1],\n    rootRef = _useTrackVisibility$.rootRef,\n    isVisible = _useTrackVisibility$.isVisible;\n  var shouldLoadMore = !disabled && !loading && isVisible && hasNextPage; // eslint-disable-next-line consistent-return\n\n  useEffect(function () {\n    if (shouldLoadMore) {\n      // When we trigger 'onLoadMore' and new items are added to the list,\n      // right before they become rendered on the screen, 'loading' becomes false\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\n      // So, it triggers 'onLoadMore' just after the first one is finished.\n      // We use a small delay here to prevent this kind of situations.\n      // It can be configured by hook args.\n      var timer = setTimeout(function () {\n        onLoadMore();\n      }, delayInMs);\n      return function () {\n        clearTimeout(timer);\n      };\n    }\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\n  return [ref, {\n    rootRef: rootRef\n  }];\n}\nexport default useInfiniteScroll;","map":{"version":3,"mappings":";;AAQA,IAAMA,mBAAmB,GAAG,GAA5B;AA8BA,SAASC,iBAAT;MACEC;IACAC;IACAC;IACAC;IACAC;0BACAC;IAAAA,wCAAYP;4BAE0BQ,kBAAkB,CAAC;MACvDH,UAAU,EAAVA;IADuD,CAAD;IAAjDI;;IAAOC;IAASC;EAIvB,IAAMC,cAAc,GAAG,CAACN,QAAD,IAAa,CAACJ,OAAd,IAAyBS,SAAzB,IAAsCR,WAA7D;;EAGAU,SAAS,CAAC;IACR,IAAID,cAAJ,EAAoB;MAClB;MACA;MACA;MACA;MACA;MACA;MACA,IAAME,KAAK,GAAGC,UAAU,CAAC;QACvBX,UAAU;MACX,CAFuB,EAErBG,SAFqB,CAAxB;MAGA,OAAO;QACLS,YAAY,CAACF,KAAD,CAAZ;MACD,CAFD;IAGD;EACF,CAfQ,EAeN,CAACV,UAAD,EAAaQ,cAAb,EAA6BL,SAA7B,CAfM,CAAT;EAiBA,OAAO,CAACE,GAAD,EAAM;IAAEC,OAAO,EAAPA;EAAF,CAAN,CAAP;AACD","names":["DEFAULT_DELAY_IN_MS","useInfiniteScroll","loading","hasNextPage","onLoadMore","rootMargin","disabled","delayInMs","useTrackVisibility","ref","rootRef","isVisible","shouldLoadMore","useEffect","timer","setTimeout","clearTimeout"],"sources":["/Users/pq584452/festbuddy/node_modules/react-infinite-scroll-hook/src/useInfiniteScroll.ts"],"sourcesContent":["import { useEffect } from 'react';\r\nimport {\r\n  useTrackVisibility,\r\n  IntersectionObserverHookArgs,\r\n  IntersectionObserverHookRefCallback as UseInfiniteScrollHookRefCallback,\r\n  IntersectionObserverHookRootRefCallback as UseInfiniteScrollHookRootRefCallback,\r\n} from 'react-intersection-observer-hook';\r\n\r\nconst DEFAULT_DELAY_IN_MS = 100;\r\n\r\nexport {\r\n  UseInfiniteScrollHookRefCallback,\r\n  UseInfiniteScrollHookRootRefCallback,\r\n};\r\n\r\nexport type UseInfiniteScrollHookResult = [\r\n  UseInfiniteScrollHookRefCallback,\r\n  { rootRef: UseInfiniteScrollHookRootRefCallback },\r\n];\r\n\r\nexport type UseInfiniteScrollHookArgs = Pick<\r\n  IntersectionObserverHookArgs,\r\n  // We pass this to 'IntersectionObserver'. We can use it to configure when to trigger 'onLoadMore'.\r\n  'rootMargin'\r\n> & {\r\n  // Some sort of \"is fetching\" info of the request.\r\n  loading: boolean;\r\n  // If the list has more items to load.\r\n  hasNextPage: boolean;\r\n  // The callback function to execute when the 'onLoadMore' is triggered.\r\n  // eslint-disable-next-line no-undef\r\n  onLoadMore: VoidFunction;\r\n  // Flag to stop infinite scrolling. Can be used in case of an error etc too.\r\n  disabled?: boolean;\r\n  // How long it should wait before triggering 'onLoadMore'.\r\n  delayInMs?: number;\r\n};\r\n\r\nfunction useInfiniteScroll({\r\n  loading,\r\n  hasNextPage,\r\n  onLoadMore,\r\n  rootMargin,\r\n  disabled,\r\n  delayInMs = DEFAULT_DELAY_IN_MS,\r\n}: UseInfiniteScrollHookArgs): UseInfiniteScrollHookResult {\r\n  const [ref, { rootRef, isVisible }] = useTrackVisibility({\r\n    rootMargin,\r\n  });\r\n\r\n  const shouldLoadMore = !disabled && !loading && isVisible && hasNextPage;\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  useEffect(() => {\r\n    if (shouldLoadMore) {\r\n      // When we trigger 'onLoadMore' and new items are added to the list,\r\n      // right before they become rendered on the screen, 'loading' becomes false\r\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\r\n      // So, it triggers 'onLoadMore' just after the first one is finished.\r\n      // We use a small delay here to prevent this kind of situations.\r\n      // It can be configured by hook args.\r\n      const timer = setTimeout(() => {\r\n        onLoadMore();\r\n      }, delayInMs);\r\n      return () => {\r\n        clearTimeout(timer);\r\n      };\r\n    }\r\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\r\n\r\n  return [ref, { rootRef }];\r\n}\r\n\r\nexport default useInfiniteScroll;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}